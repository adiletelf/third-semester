Обработаем знаковый бит

arr = [ 4, -5, 5, 3, 1, 10, -3] // i и j не изменились, меняем их местами
ind = [-3, -5, 5, 3, 1, 10,  4] // всё ещё i == 0; j == len(arr) - 1 

теперь i == 2, j == 1
потому что arr[2] не отрицательное число (цикл ++i остановился)
потому что arr[1] не положительное число (цикл --j остановился)
Мы их не меняем местами (i > j), также выходим из главного цикла: while (i <= j) 
Это означает, что все отрицательные числа находятся "слева" массива, а положительные "справа"
arr = [-3, -5, ...]

bitwise-sort - quicksort for bits

Запускаем quicksort для положительной части
(знаковый бит не учитывается, впрочем этого и не надо, т.к. все элементы в правой части массива положительные)
Тут всё просто.

Но если запустить quicksort для отрицательной части, то он,
можно предположить, отсортирует его по модулю (игнорируя знаковый бит) и получится такое:
arr = [-3, -5, ...]

Но это не так. Дело в том, что отрицательные числа представлены
В компьютеры по другому (дополнительный код)
Из-за этого при сортировке негативных чисел в доп. коде получится так:
arr = [-5, -3, ...]

В итоге:
arr = [-5, -3, 1, 3, 4, 5, 10]
